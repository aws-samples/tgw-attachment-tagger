# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT-0
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify,
# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
---

AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template to deploy the Transit Gateway Attachment Tagger'

Parameters:
  awsOrganizationsRootAccountId:
    Description: The AWS Account Id for the AWS Organizations root account
    Type: String
    Default: "123456789012"
    AllowedPattern: "\\d{12}"
    ConstraintDescription: Enter a valid AWS Account Id
  TGWRegions:
    Description: Comma-Seperated list of regions with a Transit Gateway in our core network
    Type: String
    Default: "eu-west-1,us-east-1,us-west-2,ap-southeast-1"
  TGWExclusionList:
    Description: Comma-Seperated list of TGW Ids to exclude from processing (leave blank to process all TGWs)
    Type: String
    Default: ""

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "AWS Organization Configuration"
        Parameters:
          - awsOrganizationsRootAccountId
      - Label:
          default: "Transit Gateway Configuration"
        Parameters:
          - TGWRegions
          - TGWExclusionList

Resources:

  LambdaOrganizationsAccountQueryLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: '/aws/lambda/tgw-tagger-organizations-account-query'
      RetentionInDays: 90
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "The data stored in CloudWatch Logs is not sensitive and does not warrant the additional expense of creating and using a CMK to provide encryption"

  LambdaOrganizationsAccountQueryRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: tgw-attachment-tagger-organizations-lambda-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: tgw-attachment-tagger-organizations-lambda-inline-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !GetAtt 'LambdaOrganizationsAccountQueryLogGroup.Arn'
              - Effect: Allow
                Action:
                  - sts:AssumeRole
                Resource:
                  - !Sub arn:aws:iam::${awsOrganizationsRootAccountId}:role/tgw-attachment-tagger-organization-query-role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "A single copy of this solution is to be deployed globally, resources have static names for ease of use"

  LambdaOrganizationsAccountQuery:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: tgw-tagger-organizations-account-query
      Description: Queries the AWS Organizations API in the Organization Root for account Ids and Names
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !GetAtt 'LambdaOrganizationsAccountQueryRole.Arn'
      Timeout: 60
      MemorySize: 128
      Environment:
        Variables:
          ORGANIZATIONS_ROLE_ARN: !Sub arn:aws:iam::${awsOrganizationsRootAccountId}:role/tgw-attachment-tagger-organization-query-role
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
          # SPDX-License-Identifier: MIT-0
          #
          # Permission is hereby granted, free of charge, to any person obtaining a copy of this
          # software and associated documentation files (the "Software"), to deal in the Software
          # without restriction, including without limitation the rights to use, copy, modify,
          # merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
          # permit persons to whom the Software is furnished to do so.
          #
          # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
          # INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
          # PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
          # HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
          # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
          # SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

          import boto3
          import logging
          import sys
          import traceback
          import os
          import json

          sts_client = boto3.client('sts')
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          ORGANIZATIONS_ROLE = os.environ.get('ORGANIZATIONS_ROLE_ARN')

          def log_exception(exception_type, exception_value, exception_traceback):
              """Function to create a JSON object containing exception details, which can then be logged as one line to the logger."""
              traceback_string = traceback.format_exception(exception_type, exception_value, exception_traceback)
              err_msg = json.dumps({"errorType": exception_type.__name__, "errorMessage": str(exception_value), "stackTrace": traceback_string})
              logger.error(err_msg)

          def assume_role(role_arn: str):
              """Wrapper function to assume an IAM Role."""
              try:
                  logger.info(f"Assuming Role: {role_arn}")
                  # Assume a role within the AWS Organizations root account so we can access the service endpoint
                  assumedRole = sts_client.assume_role(
                      RoleArn=role_arn,
                      RoleSessionName='cross_account_role'
                  )
              except:
                  log_exception(*sys.exc_info())    
                  raise RuntimeError(f"Could not assume role: {role_arn}")

              return boto3.Session(
                  aws_access_key_id=assumedRole['Credentials']['AccessKeyId'],
                  aws_secret_access_key=assumedRole['Credentials']['SecretAccessKey'],
                  aws_session_token=assumedRole['Credentials']['SessionToken'])

          def get_account_details_from_organization(org_object):
              """Query the Organizations API to build a list of Account Ids and Names."""
              result_object = []
              try:
                  paginator = org_object.get_paginator('list_accounts')
                  iterator  = paginator.paginate()
                  for page in iterator:
                      for account in page['Accounts']:
                          if "ACTIVE" == account['Status']:
                              logger.debug(f"Account ID {account['Id']} has status: {account['Status']}")
                              result_object.append({"id": account['Id'], "name": account['Name']})
                          else:
                              logger.debug(f"Account ID {account['Id']} has status: {account['Status']}")
              except:
                  log_exception(*sys.exc_info())
                  raise RuntimeError(f"Error calling list_accounts for the organization")
              return result_object

          def lambda_handler(event, context):
              """
              Lambda handler function. 
              
              Queries the AWS Organizations API to determine menmber account IDs and Names, before returning a list of dictionaries with account information.
              """
              boto3_session_object = assume_role(ORGANIZATIONS_ROLE)
              org_object = boto3_session_object.client('organizations')
              account_list = get_account_details_from_organization(org_object)
              logger.info(f"{account_list}")
              response_data = {}
              response_data['AccountDetails'] = account_list
              return(response_data)
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "This lambda requires access to AWS Service Endpoints so deployment into a VPC can't be guaranteed to work"
          - id: W92
            reason: "Reserved Concurrency is not relevent nor desired for this function"

  LambdaTGWAttachmentQueryLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: '/aws/lambda/tgw-tagger-attachment-query'
      RetentionInDays: 90
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "The data stored in CloudWatch Logs is not sensitive and does not warrant the additional expense of creating and using a CMK to provide encryption"

  LambdaTGWAttachmentQueryRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: tgw-attachment-tagger-attachquery-lambda-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: tgw-attachment-tagger-attachquery-lambda-inline-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !GetAtt 'LambdaTGWAttachmentQueryLogGroup.Arn'
              - Effect: Allow
                Action:
                  - ec2:DescribeTransitGatewayAttachments
                Resource: "*"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "A single copy of this solution is to be deployed globally, resources have static names for ease of use"
          - id: W11
            reason: "The DescribeTransitGatewayAttachments action cannot be locked down to specific resource Arns or paths."


  LambdaTGWAttachmentQuery:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: tgw-tagger-attachment-query
      Description: Queries the EC2 API for TGW attachment Ids
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !GetAtt 'LambdaTGWAttachmentQueryRole.Arn'
      Timeout: 900
      MemorySize: 128
      Environment:
        Variables:
          REGION_LIST: !Ref TGWRegions
          TGW_LIST: !Ref TGWExclusionList
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
          # SPDX-License-Identifier: MIT-0
          #
          # Permission is hereby granted, free of charge, to any person obtaining a copy of this
          # software and associated documentation files (the "Software"), to deal in the Software
          # without restriction, including without limitation the rights to use, copy, modify,
          # merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
          # permit persons to whom the Software is furnished to do so.
          #
          # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
          # INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
          # PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
          # HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
          # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
          # SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

          import boto3
          import logging
          import sys
          import traceback
          import os
          import json

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          REGION_LIST = os.environ.get('REGION_LIST').split(",")
          ORIGINAL_TGW_LIST = os.environ.get('TGW_LIST')

          if not REGION_LIST:
              raise RuntimeError("At least one region must be specified")

          if ORIGINAL_TGW_LIST:
              tgw_list = ORIGINAL_TGW_LIST.split(",")
          else:
              tgw_list = []

          def log_exception(exception_type, exception_value, exception_traceback):
              """Function to create a JSON object containing exception details, which can then be logged as one line to the logger."""
              traceback_string = traceback.format_exception(exception_type, exception_value, exception_traceback)
              err_msg = json.dumps({"errorType": exception_type.__name__, "errorMessage": str(exception_value), "stackTrace": traceback_string})
              logger.error(err_msg)

          def get_ec2_client(region: str):
              """Create a regional EC2 boto client."""
              return boto3.client('ec2', region_name=region)
              
          def list_transit_gateway_attachments(accountList: list, region: str):
              """Returns all TGW attachments for the specified Region."""
              logger.info(f"Getting list of TGW Attachments for region {region}")
              ec2 = get_ec2_client(region)
              result_object = []
              try:
                  # Get all TGW attachments in the region which have type: vpc and are available
                  paginator = ec2.get_paginator('describe_transit_gateway_attachments')
                  iterator  = paginator.paginate(
                      Filters=[
                          {
                              'Name': 'state',
                              'Values': [
                                  'available',
                              ]
                          },
                          {
                              'Name': 'resource-type',
                              'Values': [
                                  'vpc',
                              ]
                          },
                      ] 
                  )
              except:
                  log_exception(*sys.exc_info())
                  raise RuntimeError(f"Error getting list of TGW attachments for region {region}")
              for page in iterator:
                  for attachment in page['TransitGatewayAttachments']:
                      # Check TGW has not been excluded from processing
                      if attachment['TransitGatewayId'] not in tgw_list:
                          logger.info(f"Processing Attachment: {attachment['TransitGatewayAttachmentId']}")
                          tgw_name = "MISSING"
                          for i in attachment['Tags']:
                              # Check whether Name tag exists
                              if "Name" == i['Key']:
                                  tgw_name = i['Value']   
                          account_name = "MISSING"
                          # Check account list object for a match against the TGW resource owner
                          for account in [x for x in accountList if x['id'] == attachment['ResourceOwnerId']]:
                              account_name = account['name']           
                          result_object.append({"tgwId": attachment['TransitGatewayId'], "attachmentId": attachment['TransitGatewayAttachmentId'], "accountId": attachment['ResourceOwnerId'],"accountName": account_name, "nametag": tgw_name})
              return result_object

          def lambda_handler(event, context):
              """
              Lambda handler function. 
              
              Queries the EC2 API for Transit Gateway Attachment details for each configured region, before returning a dictionary of lists with TGW attachment information.
              """
              response_data = {}
              response_data['MapInput'] = []
              if event['AccountDetails']:
                  for region in REGION_LIST:
                      logger.info(f"Processing Region: {region}")
                      result = list_transit_gateway_attachments(event['AccountDetails'], region)
                      response_data['MapInput'].append({region: result}) 
              return(response_data)
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "This lambda requires access to AWS Service Endpoints so deployment into a VPC can't be guaranteed to work"
          - id: W92
            reason: "Reserved Concurrency is not relevent nor desired for this function"

  LambdaTGWRTBQueryLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: '/aws/lambda/tgw-tagger-rtb-query'
      RetentionInDays: 90
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "The data stored in CloudWatch Logs is not sensitive and does not warrant the additional expense of creating and using a CMK to provide encryption"

  LambdaTGWRTBQueryRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: tgw-attachment-tagger-rtbquery-lambda-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: tgw-attachment-tagger-rtbquery-lambda-inline-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !GetAtt 'LambdaTGWRTBQueryLogGroup.Arn'
              - Effect: Allow
                Action:
                  - ec2:DescribeTransitGatewayRouteTables
                  - ec2:SearchTransitGatewayRoutes
                Resource: "*"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "A single copy of this solution is to be deployed globally, resources have static names for ease of use"
          - id: W11
            reason: "The DescribeTransitGatewayRouteTables & SearchTransitGatewayRoutes actions cannot be locked down to specific resource Arns or paths."

  LambdaTGWRTBQuery:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: tgw-tagger-rtb-query
      Description: Queries the EC2 API for TGW Route Table CIDR entries
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !GetAtt 'LambdaTGWRTBQueryRole.Arn'
      Timeout: 900
      MemorySize: 128
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
          # SPDX-License-Identifier: MIT-0
          #
          # Permission is hereby granted, free of charge, to any person obtaining a copy of this
          # software and associated documentation files (the "Software"), to deal in the Software
          # without restriction, including without limitation the rights to use, copy, modify,
          # merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
          # permit persons to whom the Software is furnished to do so.
          #
          # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
          # INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
          # PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
          # HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
          # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
          # SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

          import boto3
          import logging
          import sys
          import traceback
          import os
          import json

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def log_exception(exception_type, exception_value, exception_traceback):
              """Function to create a JSON object containing exception details, which can then be logged as one line to the logger."""
              traceback_string = traceback.format_exception(exception_type, exception_value, exception_traceback)
              err_msg = json.dumps({"errorType": exception_type.__name__, "errorMessage": str(exception_value), "stackTrace": traceback_string})
              logger.error(err_msg)

          def get_ec2_client(region: str):
              """Create a regional EC2 boto client."""
              ec2 = boto3.client('ec2', region_name=region)
              return ec2

          def list_tgw_route_tables(region: str):
              """Get TGW RTB for the specified Region."""
              ec2 = get_ec2_client(region)    
              result_object = []
              try:
                  paginator = ec2.get_paginator('describe_transit_gateway_route_tables')    
                  iterator  = paginator.paginate(
                      Filters=[
                          {
                              'Name': 'state',
                              'Values': [
                                  'available',
                              ]
                          },
                      ] 
                  )
                  for page in iterator:
                      for rtb in page['TransitGatewayRouteTables']:
                          result_object.append({"tgwId": rtb['TransitGatewayId'], "rtbId": rtb['TransitGatewayRouteTableId']})
              except:
                  log_exception(*sys.exc_info())   
                  raise RuntimeError(f"Error getting TGW RTB for region {region}")    
              return result_object

          def find_tgw_attachment_cidr(attachment_id: str, route_table_list: list, region: str):
              """Get CIDR for TGW Attachment."""
              result_object = []
              for route_table in route_table_list:
                  cidr_range = search_rtb_for_attachment(attachment_id, route_table['rtbId'], region)
                  if cidr_range:
                      result_object.append({"cidr": cidr_range})
              if len(result_object) == 1:
                  return result_object[0]['cidr']
              else:
                  return None

          def search_rtb_for_attachment(attachment_id: str, route_table_id: str, region: str):
              """Search RTB for TGW Attachment."""
              ec2 = get_ec2_client(region)
              result_object = None
              try:
                  response = ec2.search_transit_gateway_routes(
                      TransitGatewayRouteTableId=route_table_id,
                      Filters=[
                          {
                              'Name': 'attachment.transit-gateway-attachment-id',
                              'Values': [
                                  attachment_id,
                              ]
                          },
                      ]
                  )
              except:
                  log_exception(*sys.exc_info())
                  raise RuntimeError(f"Error searching TGW Route Table: {route_table_id}")
              if response['Routes']:
                  # An attachment may only be associated with a single Route Table, however the API returns a list containing a single element
                  for route in response['Routes']:
                      result_object = route['DestinationCidrBlock']
              return result_object

          def lambda_handler(event, context):
              """
              Lambda handler function. 
              
              Queries the TGW route tables for the supplied region, to find out the CIDR range associated with the attachment
              """
              logger.debug(f"{event}")
              # Get the next item in the supplied dictionary. The Map iterator in the surrounding Step Function will supply a single region at a time to this function - however we do not know which at runtime
              map_region = next(iter(event))
              rtb = list_tgw_route_tables(map_region)
              for a in event[map_region]:
                  logger.info(f"Processing attachment {a['attachmentId']}")
                  cidr = find_tgw_attachment_cidr(a['attachmentId'], rtb, map_region)
                  if None is not cidr:
                      a['cidr'] = cidr
                  else:
                      a['cidr'] = "MISSING"
              return event
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "This lambda requires access to AWS Service Endpoints so deployment into a VPC can't be guaranteed to work"
          - id: W92
            reason: "Reserved Concurrency is not relevent nor desired for this function"

  LambdaTGWTagLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: '/aws/lambda/tgw-tagger-tagger'
      RetentionInDays: 90
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "The data stored in CloudWatch Logs is not sensitive and does not warrant the additional expense of creating and using a CMK to provide encryption"

  LambdaTGWTagRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: tgw-attachment-tagger-tag-lambda-role
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: tgw-attachment-tagger-tag-lambda-inline-policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !GetAtt 'LambdaTGWTagLogGroup.Arn'
              - Effect: Allow
                Action:
                  - ec2:CreateTags
                Resource: 
                  - !Sub "arn:aws:ec2:*:${AWS::AccountId}:transit-gateway-attachment/*"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "A single copy of this solution is to be deployed globally, resources have static names for ease of use"

  LambdaTGWTag:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: tgw-tagger-tagger
      Description: Updates the TGW Attachment Name tag
      Handler: index.lambda_handler
      Runtime: python3.8
      Role: !GetAtt 'LambdaTGWTagRole.Arn'
      Timeout: 60
      MemorySize: 128
      TracingConfig:
        Mode: Active
      Code:
        ZipFile: |
          # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
          # SPDX-License-Identifier: MIT-0
          #
          # Permission is hereby granted, free of charge, to any person obtaining a copy of this
          # software and associated documentation files (the "Software"), to deal in the Software
          # without restriction, including without limitation the rights to use, copy, modify,
          # merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
          # permit persons to whom the Software is furnished to do so.
          #
          # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
          # INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
          # PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
          # HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
          # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
          # SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

          import boto3
          import logging
          import sys
          import traceback
          import os
          import json

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def log_exception(exception_type, exception_value, exception_traceback):
              """Function to create a JSON object containing exception details, which can then be logged as one line to the logger."""
              traceback_string = traceback.format_exception(exception_type, exception_value, exception_traceback)
              err_msg = json.dumps({"errorType": exception_type.__name__, "errorMessage": str(exception_value), "stackTrace": traceback_string})
              logger.error(err_msg)

          def get_ec2_client(region: str):
              """Create a regional EC2 boto client."""
              ec2 = boto3.client('ec2', region_name=region)
              return ec2

          def tag_tgw_attachment(attachment: dict, region: str):
              """Apply Tags to TGW Attachments."""
              ec2 = get_ec2_client(region)
              tagValue = f"{attachment['cidr']}-{attachment['accountName']}"

              try:
                  # Add Name tag to TGW attachment
                  ec2.create_tags(
                      Resources=[
                          attachment['attachmentId'],
                      ],
                      Tags=[
                          {
                              'Key': 'Name',
                              'Value': tagValue
                          },
                      ]
                  )
              except:
                  log_exception(*sys.exc_info())
                  raise RuntimeError(f"Error updating TGW attachment tag for {attachment['attachmentId']}")

          def lambda_handler(event, context):
              """
              Lambda handler function. 
              
              Applies missing Name tags to TGW attachments where we have the necessary information and there is no existing Name tag
              """
              logger.debug(f"{event}")
              # Get the next item in the supplied dictionary. The Map iterator in the surrounding Step Function will supply a single region at a time to this function - however we do not know which at runtime
              map_region = next(iter(event))
              logger.info(f"Processing region {map_region}")
              for attachment in event[map_region]:
                  # Logic to determine whether we should tag the attachment
                  if ("MISSING" == attachment['nametag']) and ("MISSING" != attachment['cidr']):
                      # Attachment has no Name tag and we were able find the CIDR from the propagated Route Table entry
                      logger.info(f"Tagging attachment {attachment['attachmentId']}")
                      tag_tgw_attachment(attachment, map_region)
                      attachment['tagCreated'] = True
                  else:
                      logger.info(f"Skipping attachment {attachment['attachmentId']}")
                      attachment['tagCreated'] = False        
              return event
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "This lambda requires access to AWS Service Endpoints so deployment into a VPC can't be guaranteed to work"
          - id: W92
            reason: "Reserved Concurrency is not relevent nor desired for this function"


  TGWTaggerStateMachineRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: tgw-attachment-tagger-state-machine-role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - !Sub "states.${AWS::Region}.amazonaws.com"
            Action:
              - "sts:AssumeRole"
      Path: "/"
      Policies:
        - PolicyName: tgw-attachment-tagger-state-machine-inline-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt 'LambdaOrganizationsAccountQuery.Arn'
                  - !GetAtt 'LambdaTGWAttachmentQuery.Arn'
                  - !GetAtt 'LambdaTGWRTBQuery.Arn'
                  - !GetAtt 'LambdaTGWTag.Arn'
              - Effect: "Allow"
                Action:
                  - states:DescribeStateMachine
                  - states:ListExecutions
                  - states:StartExecution
                  - states:StopExecution
                  - states:DescribeExecution
                Resource:
                  - !Sub arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:tgw-attachment-tagger-state-machine
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "A single copy of this solution is to be deployed globally, resources have static names for ease of use"

  TGWTaggerStepFunction:
    Type: 'AWS::StepFunctions::StateMachine'
    Properties:
      StateMachineName: tgw-attachment-tagger-state-machine
      RoleArn: !GetAtt 'TGWTaggerStateMachineRole.Arn'
      DefinitionString:
        Fn::Sub: |-
          {
              "Comment": "A state machine to orchestrate the tagging of transit gateway attachments",
              "StartAt": "Lambda - get_account_data",
              "States": {

                  "Lambda - get_account_data": {
                      "Type": "Task",
                      "Resource": "${LambdaOrganizationsAccountQuery.Arn}",
                      "Next": "Lambda - get_tgw_attachments"
                  },
                  "Lambda - get_tgw_attachments": {
                      "Type": "Task",
                      "Resource": "${LambdaTGWAttachmentQuery.Arn}",
                      "Next": "Map - Process Regions"
                  },
                  "Map - Process Regions": {
                      "Type": "Map",
                      "ItemsPath": "$.MapInput",
                      "MaxConcurrency": 0,
                      "Iterator": {
                          "StartAt": "Lambda - get_tgw_attachment_cidr",
                          "States": {

                              "Lambda - get_tgw_attachment_cidr": {
                                  "Type": "Task",
                                  "Resource": "${LambdaTGWRTBQuery.Arn}",
                                  "Next": "Lambda - tag_tgw_attachment"
                              },
                              "Lambda - tag_tgw_attachment": {
                                  "Type": "Task",
                                  "Resource": "${LambdaTGWTag.Arn}",
                                  "End": true
                              }

                          }
                      },
                      "End": true
                  }

              }
          }

  CloudWatchEventRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: tgw-attachment-tagger-cloudwatch-event-role
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - events.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Policies:
        - PolicyName: tgw-attachment-tagger-cloudwatch-event-inline-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - states:StartExecution
                Resource:
                  - !Sub arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:tgw-attachment-tagger-state-machine
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "A single copy of this solution is to be deployed globally, resources have static names for ease of use"

  CloudWatchEventRule:
    Type: AWS::Events::Rule
    Properties:
      Description: Rule to schedule the TGW Attachment Tagger Step Function
      RoleArn: !GetAtt 'CloudWatchEventRole.Arn'
      ScheduleExpression: "cron(0 6 * * ? *)"
      Targets:
        - Arn: !GetAtt 'TGWTaggerStepFunction.Arn'
          RoleArn: !GetAtt CloudWatchEventRole.Arn
          Id: tgw-tagger-cloudwatch-event
          Input: |-
            {
                "Comment": "Dummy JSON"
            }
